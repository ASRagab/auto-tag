#!/usr/bin/env bash

set -eo pipefail

FALLBACK_TAG='0.0.0'
USAGE='USAGE:
    autotag LEVEL ENVIRONMENT [-p] [-u] [-h]
'
HELP="HELP:
    Increment git tag using given increment level.

    Positional arguments:
        LEVEL         : 'M' for major, 'm' for minor.

    Flags:
        -h, --help    : Show help and exit.
        -p, --preview : Do a dry run to show the new tag label only, without
                        creating it. This must be used as the 2nd arg i.e. after
                        the LEVEL.
"
USER_ARGS="$*"

# Dynamic variables. Unfortunately all are global but at least there are
# functions now so the script is easier to work with. Also they don't have to be
# set here even, but are set for clarity.
LEVEL_CHOICE=''
ENVIRONMENT=''
PREVIEW=''
MAJOR=''
MINOR=''
ENV=''
LAST_TAG=''
NEW_TAG=''

# Print help if appropriate args were used.
help_if_needed() {
  if [[ "$#" -eq 0 ]] || [[ "$1" == '-h' ]] || [[ "$1" == '--help' ]]; then
    echo "$USAGE"
    echo "$HELP"
    exit 1
  fi
}

# Show error for invald args.
invalid_args_error() {
  echo "üõë Invalid arguments: '$USER_ARGS'"
  echo
  echo "$USAGE"
  exit 1
}


# Process CLI arguments and set globals.
process_args() {
  LEVEL_CHOICE="$1"


  if [[ "$2" ]]; then
    if [[ "$2" == 'qa' ]] || [[ "$2" == 'prod' ]]; then
      ENVIRONMENT="$2"
    else
      invalid_args_error
    fi
  else
    ENVIRONMENT="qa"
  fi

  if [[ "$3" ]]; then
    if [[ "$3" == '-p' ]] || [[ "$3" == '--preview' ]]; then
      PREVIEW='true'
    else
      invalid_args_error
    fi
  else
    PREVIEW='false'
  fi
}

fetch_tags() {
  git fetch --tags
}

# Find the most recent tag in the current repo.
get_last_tag() {
  LAST_TAG=$(git describe --abbrev=0 --tags 2>/dev/null || true)
  LAST_TAG="${LAST_TAG:-$FALLBACK_TAG}"
  LAST_TAG="${LAST_TAG/v/}"

  # Replace dot with space then split into array.
  LAST_TAG_ARR=(${LAST_TAG//./ })

  MAJOR="${LAST_TAG_ARR[0]}"
  MINOR="${LAST_TAG_ARR[1]}"
  ENV="${LAST_TAG_ARR[2]}"
}

# Determine the new tag number.
set_level() {
  # Although the exit only happens after fetching, this needs to happen here so
  # variables are set.
  # Otherwise a refactor is needed to check M|m|b and exit if needed, then
  # actually calculate here.
  case "$LEVEL_CHOICE" in
  "M")
    ((MAJOR += 1))
    MINOR=0
    ENV=qa
    ;;
  "m")
    ((MINOR += 1))
    ENV=qa
    ;;
    invalid_args_error
    ;;
  esac
}

# Create Git tag.
make_tag() {
  git tag -a "$NEW_TAG" \
    -m "$NEW_TAG"
}

run() {
  echo 'üöõ Fetching tags...'
  fetch_tags

  echo 'üîç Finding most recent tag...'
  get_last_tag
  echo "üë¥ Last tag: v$MAJOR.$MINOR.$ENVIRONMENT"

  set_level
  NEW_TAG="v$MAJOR.$MINOR.$ENVIRONMENT"
  echo "‚≠ê New tag: $NEW_TAG"

  # For some reason these emojis need a double space after to avoid looking
  # squashed, at least on macOS.
  if [[ "$PREVIEW" == true ]]; then
    echo '‚è≠Ô∏è  Skipping tag creation'
  else
    echo 'üè∑Ô∏è  Creating annotated tag...'
    make_tag
  fi
}

# Command-line entry-point.
main() {
  help_if_needed $@
  process_args $@
  run
}

main $@
